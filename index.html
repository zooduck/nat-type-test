<!DOCTYPE html>
<html>
  <body>
    <main id="nat-info">
      You are behind a <span id="nat-type">???</span> NAT. ICE gathering time is: <span id="ice-gathering-time">???</span>s.
    </main>
    <script type="module">
      class NetworkUtils {
        #connection;
        #iceGatheringComplete;
        #natTypeResolve;
        #isInitialising;
        #natType;
        constructor() {
          this.init();
        }
        /**
         * @method
         * @returns {Promise<'non-symmetric'|'symmetric'>}
         */
        async getNATType() {
          await this.#iceGatheringComplete;
          return this.#natType;
        }
        /**
         * @method
         * @param {{urls: string}[]} iceServers
         * @returns {Promise<number>}
         */
        async getICEGatheringTime(iceServers) {
          if (!iceServers?.[0]?.urls) {
            throw new Error('You must specify at least one ICE server.');
          }
          return new Promise((resolve) => {
            const connection = new RTCPeerConnection({ iceServers: iceServers });
            connection.createDataChannel('bananas');
            connection.onicecandidate = (event) => {
              const { target: connection } = event;
              if (connection.iceGatheringState === 'complete') {
                performance.mark('end');
                const { duration } = performance.measure('iceGatheringTime', 'start', 'end');
                const iceGatheringTime = parseFloat(new Number(duration / 1000).toFixed(2));
                resolve(iceGatheringTime);
              }
            }
            performance.mark('start');
            connection.createOffer().then((offer) =>  {
              connection.setLocalDescription(offer);
            });
          });
        }
        /**
         * @method
         * @returns {void}
         */
        init() {
          if (this.#isInitialising) {
            return;
          }
          this.#isInitialising = true;
          this.#connection = new RTCPeerConnection();
          this.#connection.createDataChannel('bananas');
          this.#iceGatheringComplete = new Promise((resolve) => {
            this.#natTypeResolve = resolve;
          });
          this.#createConnection();
        }
        /**
         * @private
         * @method
         * @returns {void}
         */
        #createConnection() {
          const udpHostCandidates = [];
          const tcpHostCandidates = [];
          this.#connection.onicecandidate = (event) => {
            const { target: connection } = event;
            // ----------------------------------------------------------------------
            // Chrome includes all the candidate properties in the candidate object
            // but Firefox does not (so we need to parse the candidate string).
            // ----------------------------------------------------------------------
            const parsedCandidate = this.#parseCandidate(event.candidate);
            if (parsedCandidate?.type === 'host' && parsedCandidate.protocol === 'udp') {
              udpHostCandidates.push(parsedCandidate);
            } else if (parsedCandidate?.type === 'host' && parsedCandidate.protocol === 'tcp') {
              tcpHostCandidates.push(parsedCandidate);
            }
            if (connection.iceGatheringState === 'complete') {
              const isSymmetricNAT = udpHostCandidates.length > 1 || tcpHostCandidates.length > 1;
              console.log('udpHostCandidates', udpHostCandidates, 'tcpHostCandidates', tcpHostCandidates);
              // -------------------------------------------------
              // Note: There are four NAT types defined in STUN:
              // 1. Full-cone NAT
              // 2. Address-restricted cone NAT
              // 3. Port-restricted cone NAT
              // 4. Symmetric NAT (requires TURN server)
              // -------------------------------------------------------
              // Symnmetric NAT requires a TURN server because it
              // maps requests from the same source (host) IP address
              // and port to different public IP addresses and ports
              // for each destination (and since the STUN server is not
              // the final destination - the remote peer's public IP is)
              // a TURN server with is required to relay the connection.
              // -------------------------------------------------------
              this.#natType = isSymmetricNAT ? 'symmetric' : 'non-symmetric';
              this.#natTypeResolve();
              this.#isInitialising = false;
            }
          }
          this.#connection.createOffer().then((offer) =>  {
            this.#connection.setLocalDescription(offer);
          });
        }
        /**
         * @private
         * @method
         * @param {RTCIceCandidate} candidate
         * @returns {RTCIceCandidate}
         */
        #parseCandidate(candidate) {
          if (!candidate || !candidate.candidate) {
            return candidate;
          }

          const { candidate: candidateString } = candidate;
          const parts = candidateString.split(' ');
          const address = parts[4];
          const port = parts[5];
          const protocol = parts[2];
          const type = candidateString.match(/typ ([^ ]+)/)[1];

          return {
            address: address,
            candidate: candidateString,
            port: parseInt(port, 10),
            protocol: protocol.toLowerCase(),
            type: type
          };
        }
      }

      const networkUtils = new NetworkUtils();

      window.networkUtils = networkUtils;

      networkUtils.getNATType().then((natType) => {
        document.getElementById('nat-type').textContent = natType;
      });
      networkUtils.getICEGatheringTime([
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' }
      ]).then((iceGatheringTime) => {
        document.getElementById('ice-gathering-time').textContent = iceGatheringTime;
      });
    </script>
  </body>
</html>